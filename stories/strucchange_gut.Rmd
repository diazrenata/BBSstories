---
title: "Exploring strucchange on several datasets"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(ggplot2)
library(strucchange)
```

### Strucchange method

So I think there's the bones of a potential method here, to code up and gut-check on a handful of datasets...

1. Fit:

`breakpoints(response ~ year)` and `breakpoints(response ~ 1)`

2. Use BIC to select slope or intercept model


### Trying on a few real datasets

```{r loading some real datasets, fig.dim = c(6, 20)}

datasets <- data.frame(
  dataset_name = c("rockies",
                   "hartland",
                   "alberta",
                   "cochise_birds",
                   "salamonie",
                   "tilden",
                   "gainesville",
                   "gainesville_nooutlier",
                   "portal_rats"),
  rtrg_code = c("rtrg_304_17",
                "rtrg_102_18",
                "rtrg_105_4",
                "rtrg_133_6",
                "rtrg_19_35",
                "rtrg_172_14",
                "rtrg_113_25",
                                "rtrg_113_25",

                NA)
)

all_datasets <- list()

for(i in 1:nrow(datasets)) {
  
  if(datasets$dataset_name[i] != "portal_rats") {
    
    ibd <- readRDS(paste0("C:\\Users\\diaz.renata\\Documents\\GitHub\\BBSsize\\analysis\\isd_data\\ibd_isd_bbs_", datasets$rtrg_code[i], ".Rds"))
    
    sv <- ibd %>%
      group_by(year) %>%
      summarize(richness = length(unique(id)),
                abundance = dplyr::n(),
                biomass = sum(ind_size),
                energy = sum(ind_b)) %>%
      ungroup() %>%
      mutate(mean_energy = energy / abundance,
             mean_mass = biomass/abundance,
             site_name = datasets$dataset_name[i])
    
    if(datasets$dataset_name[i] == "gainesville_nooutlier") {
      sv <- filter(sv, abundance < 3000)
    }
  } else {
    
    individual_rats <- portalr::summarise_individual_rodents(clean = TRUE, type = "Granivores", time = "date", length = "Longterm")
    
    ibd <- individual_rats %>%
      filter(year %in% c(1978:2002), !is.na(wgt), treatment == "control") %>%
      mutate(six_mo = ifelse(month > 6, .5, 0)) %>%
      mutate(year_six_mo = (year + six_mo)) %>%
      mutate(bmr = 5.69 * (wgt ^ .75)) %>%
      select(year_six_mo, species, wgt, bmr) %>%
      rename(year= year_six_mo,
             id = species,
             ind_size = wgt,
             ind_b = bmr) %>%
      mutate(id = as.character(id))
    
    
    sv <- ibd %>%
      group_by(year) %>%
      summarize(richness = length(unique(id)),
                abundance = dplyr::n(),
                biomass = sum(ind_size),
                energy = sum(ind_b)) %>%
      ungroup() %>%
      mutate(mean_energy = energy / abundance,
             mean_mass = biomass/abundance,
             site_name = datasets$dataset_name[i]) %>%
      mutate(time = row_number())
    
  }
  
  all_datasets[[i]] <- sv
  
}

all_datasets <- bind_rows(all_datasets)

gridExtra::grid.arrange(grobs = list(
  ggplot(all_datasets, aes(year, abundance, color = site_name)) +
  geom_line() +
  theme_bw() +
  facet_wrap(vars(site_name), scales = "free", ncol = 1) + 
    ggtitle("Abundance"
    ) +
   theme(legend.position = "top"),
  ggplot(all_datasets, aes(year, energy, color = site_name)) + 
 geom_line() +
  theme_bw() +
  facet_wrap(vars(site_name), scales = "free", ncol = 1) +
   ggtitle("Energy") +
   theme(legend.position = "top")),
 ncol = 2
)

```

```{r breakpoints fxns}

fit_breakpoints <- function(dat, h = 4) {

  
  bp_int <- breakpoints(formula = response ~ 1, data = dat, h =h)
  
  bp_slope <- breakpoints(formula = response ~ time, data = dat, h = h)
  
  int_BIC <- BIC(bp_int)
  slope_BIC <- BIC(bp_slope)
  
  if(int_BIC < slope_BIC) {
    return(bp_int)
  } else {
    return(bp_slope)
  }
  
}

predict_breakpoints <- function(dat, breakpoints_fit) {
 
  dat <- dat %>%
    dplyr::mutate(fitted = fitted(breakpoints_fit),
                  breakpoints = dplyr::row_number() %in% breakpoints_fit$breakpoints) 
  
  return(dat)
}

plot_breakpoint_fit <- function(dat, h = 4) {
  
  if(!("fitted" %in% colnames(dat))) {
    bps <- fit_breakpoints(dat, h = h)
    dat <- predict_breakpoints(dat, bps)
  }
  
return(ggplot(dat, aes(x = time, y = response)) +
  geom_point() +
  geom_line(aes(x = time, y = fitted)) +
  theme_bw() +
  geom_vline(xintercept = dat$time[which(dat$breakpoints)]) +
    ggtitle(dat$site_name[1]))
  
}

subset_all_datasets <- function(site, curr, all_datasets) {
  
  dat <- all_datasets[ , c("site_name", "year", curr)]
  
  dat <- dat[ which(dat$site_name == site), ]
  
  colnames(dat)[ which(colnames(dat) == curr)]  <- "response"
  colnames(dat)[ which(colnames(dat) == "year")] <- "time"
  
  return(dat)

}

dat <- subset_all_datasets("portal_rats", "abundance", all_datasets)

rats_bp <- fit_breakpoints(dat)

dat <- predict_breakpoints(dat, rats_bp)

print(plot_breakpoint_fit(dat))

```

```{r multiple datasets}

abund_plots <- list()

for(i in 1:nrow(datasets)) {
  thisdat <- subset_all_datasets(site = datasets$dataset_name[i], curr = "abundance", all_datasets = all_datasets)
  
  abund_plots[[i]] <- plot_breakpoint_fit(thisdat)
}

gridExtra::grid.arrange(grobs = abund_plots)



energy_plots <- list()

for(i in 1:nrow(datasets)) {
  thisdat <- subset_all_datasets(site = datasets$dataset_name[i], curr = "energy", all_datasets = all_datasets)
  
  energy_plots[[i]] <- plot_breakpoint_fit(thisdat)
}

gridExtra::grid.arrange(grobs = energy_plots)
```


#### h

Above, I set the minimum number of observations in a segment to 4. This is because setting it to 2 is too few (needs to be > regressors), and setting it to 3 gave Extremely Complex results that tend to involve many tiny sections (see below). It's subjective, but my assessment is these are overfitting/overfitting relative to what I see as the major signals in the data. 

For example, I think 6 segments is excessive for the `cochise_birds` data, and am more comfortable with the 3 segments achieved via `h = 4`. `cochise_birds` only has 18 datapoints, and splitting it into 6 is a little absurd....

Note also that the default in `strucchange` is `h = .15 * (nobs)`. For these timeseries, that's 3-4 depending on the length of the timeseries. 


```{r h at 3}

abund_plots_h3 <- list()

for(i in 1:nrow(datasets)) {
  thisdat <- subset_all_datasets(site = datasets$dataset_name[i], curr = "abundance", all_datasets = all_datasets)
  
  abund_plots_h3[[i]] <- plot_breakpoint_fit(thisdat, h = 3)
}

gridExtra::grid.arrange(grobs = abund_plots_h3)



energy_plots_h3 <- list()

for(i in 1:nrow(datasets)) {
  thisdat <- subset_all_datasets(site = datasets$dataset_name[i], curr = "energy", all_datasets = all_datasets)
  
  energy_plots_h3[[i]] <- plot_breakpoint_fit(thisdat, h = 3)
}

gridExtra::grid.arrange(grobs = energy_plots_h3)

```
